"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DebouncerClient = exports.Debouncer = exports.debouncerWorkflowFunction = void 0;
const node_crypto_1 = require("node:crypto");
const _1 = require(".");
const dbos_executor_1 = require("./dbos-executor");
const decorators_1 = require("./decorators");
const error_1 = require("./error");
const utils_1 = require("./utils");
const _DEBOUNCER_TOPIC = 'DEBOUNCER_TOPIC';
const debouncerWorkflowFunction = async (initialDebouncePeriodMs, cfg, ...args) => {
    let workflowInputs = args;
    const debounceDeadlineEpochMs = cfg.debounceTimeoutMs ? Date.now() + cfg.debounceTimeoutMs : Number.MAX_VALUE;
    let debouncePeriodMs = initialDebouncePeriodMs;
    while (Date.now() < debounceDeadlineEpochMs) {
        const timeUntilDeadline = Math.max(debounceDeadlineEpochMs - Date.now(), 0);
        const timeoutMs = Math.min(debouncePeriodMs, timeUntilDeadline);
        const message = await _1.DBOS.recv(_DEBOUNCER_TOPIC, timeoutMs / 1000);
        if (message === null) {
            break;
        }
        else {
            workflowInputs = message['args'];
            debouncePeriodMs = message['debouncePeriodMs'];
            await _1.DBOS.setEvent(message.messageID, message.messageID);
        }
    }
    const methReg = (0, decorators_1.getFunctionRegistrationByName)(cfg.workflowClassName, cfg.workflowName);
    if (!methReg || !methReg.registeredFunction) {
        throw Error(`Invalid workflow name provided to debouncer: ${cfg.workflowName}`);
    }
    const func = methReg?.registeredFunction;
    await _1.DBOS.startWorkflow(func, cfg.startWorkflowParams)(...workflowInputs);
};
exports.debouncerWorkflowFunction = debouncerWorkflowFunction;
class Debouncer {
    cfg;
    constructor(params) {
        const wInfo = (0, decorators_1.getFunctionRegistration)(params.workflow);
        this.cfg = {
            workflowName: wInfo?.name ?? params.workflow.name,
            workflowClassName: (0, decorators_1.getRegisteredFunctionClassName)(params.workflow),
            startWorkflowParams: params.startWorkflowParams,
            debounceTimeoutMs: params.debounceTimeoutMs,
        };
    }
    async debounce(debounceKey, debouncePeriodMs, ...args) {
        if (debouncePeriodMs <= 0) {
            throw Error(`debouncePeriodMs must be positive, not ${debouncePeriodMs}`);
        }
        const cfg = { ...this.cfg };
        cfg.startWorkflowParams = this.cfg.startWorkflowParams ? { ...this.cfg.startWorkflowParams } : {};
        cfg.startWorkflowParams.workflowID = cfg.startWorkflowParams.workflowID ?? (await _1.DBOS.randomUUID());
        while (true) {
            const deduplicationID = `${cfg.workflowClassName}.${cfg.workflowName}-${debounceKey}`;
            try {
                // Attempt to enqueue a debouncer for this workflow
                await _1.DBOS.startWorkflow(dbos_executor_1.DBOSExecutor.debouncerWorkflow, {
                    queueName: utils_1.INTERNAL_QUEUE_NAME,
                    enqueueOptions: { deduplicationID },
                })(debouncePeriodMs, cfg, ...args);
                return _1.DBOS.retrieveWorkflow(cfg.startWorkflowParams.workflowID);
            }
            catch (e) {
                // If there is already a debouncer, send a message to it.
                if (e instanceof Error && (0, error_1.getDBOSErrorCode)(e) === error_1.QueueDedupIDDuplicated) {
                    const dedupWorkflowID = await _1.DBOS.runStep(async () => {
                        return await dbos_executor_1.DBOSExecutor.globalInstance?.systemDatabase.getDeduplicatedWorkflow(utils_1.INTERNAL_QUEUE_NAME, deduplicationID);
                    });
                    if (!dedupWorkflowID) {
                        continue;
                    }
                    else {
                        const messageID = await _1.DBOS.randomUUID();
                        const message = {
                            messageID,
                            args,
                            debouncePeriodMs,
                        };
                        await _1.DBOS.send(dedupWorkflowID, message, _DEBOUNCER_TOPIC);
                        // Wait for the debouncer to acknowledge receipt of the message.
                        // If the message is not acknowledged, this likely means the debouncer started its workflow
                        // and exited without processing this message, so try again.
                        const event = await _1.DBOS.getEvent(dedupWorkflowID, messageID, 1000);
                        if (!event) {
                            continue;
                        }
                        // Retrieve the user workflow ID from the input to the debouncer
                        // and return a handle to it.
                        const dedupWorkflowInput = await _1.DBOS.retrieveWorkflow(dedupWorkflowID).getWorkflowInputs();
                        const typedInput = dedupWorkflowInput;
                        const userWorkflowID = typedInput[1].startWorkflowParams.workflowID;
                        return _1.DBOS.retrieveWorkflow(userWorkflowID);
                    }
                }
                else {
                    throw e;
                }
            }
        }
    }
}
exports.Debouncer = Debouncer;
class DebouncerClient {
    client;
    cfg;
    constructor(client, params) {
        this.client = client;
        this.cfg = {
            workflowName: params.workflowName,
            workflowClassName: params.workflowClassName || '',
            startWorkflowParams: params.startWorkflowParams,
            debounceTimeoutMs: params.debounceTimeoutMs,
        };
    }
    async debounce(debounceKey, debouncePeriodMs, ...args) {
        if (debouncePeriodMs <= 0) {
            throw Error(`debouncePeriodMs must be positive, not ${debouncePeriodMs}`);
        }
        const cfg = { ...this.cfg };
        cfg.startWorkflowParams = this.cfg.startWorkflowParams ? { ...this.cfg.startWorkflowParams } : {};
        cfg.startWorkflowParams.workflowID = cfg.startWorkflowParams.workflowID ?? String((0, node_crypto_1.randomUUID)());
        while (true) {
            const deduplicationID = `${cfg.workflowClassName}.${cfg.workflowName}-${debounceKey}`;
            try {
                // Attempt to enqueue a debouncer for this workflow
                await this.client.enqueue({ workflowName: utils_1.DEBOUNCER_WORKLOW_NAME, queueName: utils_1.INTERNAL_QUEUE_NAME, deduplicationID }, debouncePeriodMs, cfg, ...args);
                return this.client.retrieveWorkflow(cfg.startWorkflowParams.workflowID);
            }
            catch (e) {
                // If there is already a debouncer, send a message to it.
                if (e instanceof Error && (0, error_1.getDBOSErrorCode)(e) === error_1.QueueDedupIDDuplicated) {
                    // Access the private client system database
                    // eslint-disable-next-line @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-explicit-any
                    const dedupWorkflowID = (await this.client.systemDatabase.getDeduplicatedWorkflow(utils_1.INTERNAL_QUEUE_NAME, deduplicationID));
                    if (!dedupWorkflowID) {
                        continue;
                    }
                    else {
                        const messageID = String((0, node_crypto_1.randomUUID)());
                        const message = {
                            messageID,
                            args,
                            debouncePeriodMs,
                        };
                        await this.client.send(dedupWorkflowID, message, _DEBOUNCER_TOPIC);
                        // Wait for the debouncer to acknowledge receipt of the message.
                        // If the message is not acknowledged, this likely means the debouncer started its workflow
                        // and exited without processing this message, so try again.
                        const event = await this.client.getEvent(dedupWorkflowID, messageID, 1000);
                        if (!event) {
                            continue;
                        }
                        // Retrieve the user workflow ID from the input to the debouncer
                        // and return a handle to it.
                        const dedupWorkflowInput = await this.client.retrieveWorkflow(dedupWorkflowID).getWorkflowInputs();
                        const typedInput = dedupWorkflowInput;
                        const userWorkflowID = typedInput[1].startWorkflowParams.workflowID;
                        return this.client.retrieveWorkflow(userWorkflowID);
                    }
                }
                else {
                    throw e;
                }
            }
        }
    }
}
exports.DebouncerClient = DebouncerClient;
//# sourceMappingURL=debouncer.js.map
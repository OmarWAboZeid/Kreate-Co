import { SystemDatabase } from './system_database';
import { ConfiguredInstance } from './decorators';
import { EnqueueOptions } from './system_database';
export interface WorkflowParams {
    workflowUUID?: string;
    configuredInstance?: ConfiguredInstance | null;
    queueName?: string;
    executeWorkflow?: boolean;
    timeoutMS?: number | null;
    deadlineEpochMS?: number;
    enqueueOptions?: EnqueueOptions;
}
export declare const DEFAULT_MAX_RECOVERY_ATTEMPTS = 100;
/**
 * Configuration for `DBOS.workflow` functions
 */
export interface WorkflowConfig {
    /** Maximum number of recovery attempts to make on workflow function, before sending to dead-letter queue */
    maxRecoveryAttempts?: number;
    /** Name to use */
    name?: string;
}
export interface WorkflowStatus {
    readonly workflowID: string;
    readonly status: string;
    readonly workflowName: string;
    readonly workflowClassName: string;
    readonly workflowConfigName?: string;
    readonly queueName?: string;
    readonly authenticatedUser?: string;
    readonly assumedRole?: string;
    readonly authenticatedRoles?: string[];
    readonly input?: unknown[];
    readonly output?: unknown;
    readonly error?: unknown;
    readonly executorId?: string;
    readonly applicationVersion?: string;
    readonly createdAt: number;
    readonly updatedAt?: number;
    readonly timeoutMS?: number;
    readonly deadlineEpochMS?: number;
    readonly deduplicationID?: string;
    readonly priority: number;
    readonly queuePartitionKey?: string;
    readonly forkedFrom?: string;
    readonly applicationID: string;
    readonly request?: object;
    readonly recoveryAttempts?: number;
}
export interface GetWorkflowsInput {
    workflowIDs?: string[];
    workflowName?: string;
    status?: 'PENDING' | 'SUCCESS' | 'ERROR' | 'MAX_RECOVERY_ATTEMPTS_EXCEEDED' | 'CANCELLED' | 'ENQUEUED';
    startTime?: string;
    endTime?: string;
    authenticatedUser?: string;
    applicationVersion?: string;
    executorId?: string;
    workflow_id_prefix?: string;
    queueName?: string;
    queuesOnly?: boolean;
    forkedFrom?: string;
    limit?: number;
    offset?: number;
    sortDesc?: boolean;
    loadInput?: boolean;
    loadOutput?: boolean;
}
export interface GetPendingWorkflowsOutput {
    workflowUUID: string;
    queueName?: string;
}
export interface StepInfo {
    readonly functionID: number;
    readonly name: string;
    readonly output: unknown;
    readonly error: Error | null;
    readonly childWorkflowID: string | null;
    readonly startedAtEpochMs?: number;
    readonly completedAtEpochMs?: number;
}
export interface PgTransactionId {
    txid: string;
}
/** Enumeration of values for workflow status */
export declare const StatusString: {
    /** Workflow has may be running */
    readonly PENDING: "PENDING";
    /** Workflow complete with return value */
    readonly SUCCESS: "SUCCESS";
    /** Workflow complete with error thrown */
    readonly ERROR: "ERROR";
    /** Workflow has exceeded its maximum number of execution or recovery attempts */
    readonly MAX_RECOVERY_ATTEMPTS_EXCEEDED: "MAX_RECOVERY_ATTEMPTS_EXCEEDED";
    /** Workflow is being, or has been, cancelled */
    readonly CANCELLED: "CANCELLED";
    /** Workflow is on a `WorkflowQueue` and has not yet started */
    readonly ENQUEUED: "ENQUEUED";
};
export declare function isWorkflowActive(status: string): boolean;
/**
 * Object representing an active or completed workflow execution, identified by the workflow UUID.
 * Allows retrieval of information about the workflow.
 */
export interface WorkflowHandle<R> {
    /**
     * Retrieve the workflow's status.
     * Statuses are updated asynchronously.
     */
    getStatus(): Promise<WorkflowStatus | null>;
    /**
     * Await workflow completion and return its result.
     */
    getResult(): Promise<R>;
    /**
     * Return the workflow's ID
     */
    get workflowID(): string;
    /**
     * Return the workflow's inputs
     */
    getWorkflowInputs<T extends any[]>(): Promise<T>;
}
export interface InternalWFHandle<R> extends WorkflowHandle<R> {
    getResult(funcIdForGet?: number): Promise<R>;
}
/**
 * The handle returned when invoking a workflow with DBOSExecutor.workflow
 */
export declare class InvokedHandle<R> implements InternalWFHandle<R> {
    readonly systemDatabase: SystemDatabase;
    readonly workflowPromise: Promise<R>;
    readonly workflowUUID: string;
    readonly workflowName: string;
    constructor(systemDatabase: SystemDatabase, workflowPromise: Promise<R>, workflowUUID: string, workflowName: string);
    getWorkflowUUID(): string;
    get workflowID(): string;
    getStatus(): Promise<WorkflowStatus | null>;
    getResult(funcIdForGet?: number): Promise<R>;
    getWorkflowInputs<T extends any[]>(): Promise<T>;
}
/**
 * The handle returned when retrieving a workflow with DBOSExecutor.retrieve
 */
export declare class RetrievedHandle<R> implements InternalWFHandle<R> {
    readonly systemDatabase: SystemDatabase;
    readonly workflowUUID: string;
    constructor(systemDatabase: SystemDatabase, workflowUUID: string);
    getWorkflowUUID(): string;
    get workflowID(): string;
    getStatus(): Promise<WorkflowStatus | null>;
    getResult(funcIdForGet?: number): Promise<R>;
    getWorkflowInputs<T extends any[]>(): Promise<T>;
}
//# sourceMappingURL=workflow.d.ts.map
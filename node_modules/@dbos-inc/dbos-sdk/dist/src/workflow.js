"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RetrievedHandle = exports.InvokedHandle = exports.isWorkflowActive = exports.StatusString = exports.DEFAULT_MAX_RECOVERY_ATTEMPTS = void 0;
const serialization_1 = require("./serialization");
const dbos_1 = require("./dbos");
const dbos_executor_1 = require("./dbos-executor");
exports.DEFAULT_MAX_RECOVERY_ATTEMPTS = 100;
/** Enumeration of values for workflow status */
exports.StatusString = {
    /** Workflow has may be running */
    PENDING: 'PENDING',
    /** Workflow complete with return value */
    SUCCESS: 'SUCCESS',
    /** Workflow complete with error thrown */
    ERROR: 'ERROR',
    /** Workflow has exceeded its maximum number of execution or recovery attempts */
    MAX_RECOVERY_ATTEMPTS_EXCEEDED: 'MAX_RECOVERY_ATTEMPTS_EXCEEDED',
    /** Workflow is being, or has been, cancelled */
    CANCELLED: 'CANCELLED',
    /** Workflow is on a `WorkflowQueue` and has not yet started */
    ENQUEUED: 'ENQUEUED',
};
function isWorkflowActive(status) {
    return status === exports.StatusString.PENDING || status === exports.StatusString.ENQUEUED;
}
exports.isWorkflowActive = isWorkflowActive;
/**
 * The handle returned when invoking a workflow with DBOSExecutor.workflow
 */
class InvokedHandle {
    systemDatabase;
    workflowPromise;
    workflowUUID;
    workflowName;
    constructor(systemDatabase, workflowPromise, workflowUUID, workflowName) {
        this.systemDatabase = systemDatabase;
        this.workflowPromise = workflowPromise;
        this.workflowUUID = workflowUUID;
        this.workflowName = workflowName;
    }
    getWorkflowUUID() {
        return this.workflowUUID;
    }
    get workflowID() {
        return this.workflowUUID;
    }
    async getStatus() {
        return await dbos_1.DBOS.getWorkflowStatus(this.workflowUUID);
    }
    async getResult(funcIdForGet) {
        return await (0, dbos_1.runInternalStep)(async () => {
            return await this.workflowPromise;
        }, 'DBOS.getResult', this.workflowUUID, funcIdForGet);
    }
    async getWorkflowInputs() {
        const status = (await this.systemDatabase.getWorkflowStatus(this.workflowUUID));
        return this.systemDatabase.getSerializer().parse(status.input);
    }
}
exports.InvokedHandle = InvokedHandle;
/**
 * The handle returned when retrieving a workflow with DBOSExecutor.retrieve
 */
class RetrievedHandle {
    systemDatabase;
    workflowUUID;
    constructor(systemDatabase, workflowUUID) {
        this.systemDatabase = systemDatabase;
        this.workflowUUID = workflowUUID;
    }
    getWorkflowUUID() {
        return this.workflowUUID;
    }
    get workflowID() {
        return this.workflowUUID;
    }
    async getStatus() {
        return await dbos_1.DBOS.getWorkflowStatus(this.workflowUUID);
    }
    async getResult(funcIdForGet) {
        return (await dbos_1.DBOS.getResultInternal(this.workflowUUID, undefined, undefined, funcIdForGet));
    }
    async getWorkflowInputs() {
        const status = (await this.systemDatabase.getWorkflowStatus(this.workflowUUID));
        return this.systemDatabase.getSerializer().parse(status.input);
    }
}
exports.RetrievedHandle = RetrievedHandle;
(0, serialization_1.registerSerializationRecipe)({
    name: 'DBOS.WorkflowHandle',
    isApplicable: (v) => {
        return v instanceof RetrievedHandle || v instanceof InvokedHandle;
    },
    serialize: (v) => {
        return { wfid: v.workflowID };
    },
    deserialize: (s) => new RetrievedHandle(dbos_executor_1.DBOSExecutor.globalInstance.systemDatabase, s.wfid),
});
//# sourceMappingURL=workflow.js.map
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.safeParseError = exports.safeParse = exports.serializeFunctionInputOutput = exports.DBOSJSON = exports.SERIALIZER_MARKER_VALUE = exports.SERIALIZER_MARKER_KEY = exports.DBOSJSONLegacy = exports.DBOSReviver = exports.DBOSReplacer = exports.registerSerializationRecipe = void 0;
const serialize_error_1 = require("serialize-error");
const superjson_1 = __importDefault(require("superjson"));
function registerSerializationRecipe(r) {
    superjson_1.default.registerCustom(r, r.name);
}
exports.registerSerializationRecipe = registerSerializationRecipe;
// Register Buffer transformer for SuperJSON
registerSerializationRecipe({
    isApplicable: (v) => Buffer.isBuffer(v),
    serialize: (v) => Array.from(v),
    deserialize: (v) => Buffer.from(v),
    name: 'Buffer',
});
//https://www.typescriptlang.org/docs/handbook/2/functions.html#declaring-this-in-a-function
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function DBOSReplacer(key, value) {
    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-assignment
    const actualValue = this[key];
    if (actualValue instanceof Date) {
        const res = {
            dbos_type: 'dbos_Date',
            dbos_data: actualValue.toISOString(),
        };
        return res;
    }
    if (typeof actualValue === 'bigint') {
        const res = {
            dbos_type: 'dbos_BigInt',
            dbos_data: actualValue.toString(),
        };
        return res;
    }
    return value;
}
exports.DBOSReplacer = DBOSReplacer;
function isSerializedBuffer(value) {
    return typeof value === 'object' && value !== null && value.type === 'Buffer';
}
function isSerializedDate(value) {
    return typeof value === 'object' && value !== null && value.dbos_type === 'dbos_Date';
}
function isSerializedBigInt(value) {
    return typeof value === 'object' && value !== null && value.dbos_type === 'dbos_BigInt';
}
function DBOSReviver(_key, value) {
    switch (true) {
        case isSerializedBuffer(value):
            return Buffer.from(value.data);
        case isSerializedDate(value):
            return new Date(Date.parse(value.dbos_data));
        case isSerializedBigInt(value):
            return BigInt(value.dbos_data);
        default:
            return value;
    }
}
exports.DBOSReviver = DBOSReviver;
// Keep the old DBOSJSON implementation for reference/testing
exports.DBOSJSONLegacy = {
    parse: (text) => {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-return
        return text === null ? null : JSON.parse(text, DBOSReviver);
    },
    stringify: (value) => {
        return JSON.stringify(value, DBOSReplacer);
    },
};
// Constants for SuperJSON serialization marker
exports.SERIALIZER_MARKER_KEY = '__dbos_serializer';
exports.SERIALIZER_MARKER_VALUE = 'superjson';
const SERIALIZER_MARKER_STRING = `"${exports.SERIALIZER_MARKER_KEY}":"${exports.SERIALIZER_MARKER_VALUE}"`;
/**
 * Detects if a parsed object was serialized by our DBOSJSON with SuperJSON.
 * We check for our explicit marker to avoid ANY ambiguity with user data.
 * Also validates the object has the shape expected by superjson.deserialize().
 */
function isDBOSBrandedSuperjsonRecord(obj) {
    return (typeof obj === 'object' &&
        obj !== null &&
        exports.SERIALIZER_MARKER_KEY in obj &&
        obj[exports.SERIALIZER_MARKER_KEY] === exports.SERIALIZER_MARKER_VALUE &&
        'json' in obj);
}
function sjstringify(value) {
    // Use SuperJSON for all new serialization
    const serialized = superjson_1.default.serialize(value);
    // Add our explicit marker to make detection unambiguous
    return JSON.stringify({
        ...serialized,
        [exports.SERIALIZER_MARKER_KEY]: exports.SERIALIZER_MARKER_VALUE,
    });
}
/**
 * DBOSJSON with SuperJSON support for richer type serialization.
 *
 * Backwards compatible - can deserialize both old DBOSJSON format and new SuperJSON format.
 * New serialization uses SuperJSON to handle Sets, Maps, undefined, RegExp, circular refs, etc.
 */
exports.DBOSJSON = {
    parse: (text) => {
        if (text === null || text === undefined)
            return null; // This is from legacy; SuperJSON can do it.
        /**
         * Performance optimization: String check before JSON parsing.
         *
         * Why not just parse once and check the resulting object?
         * - Legacy DBOSJSON data needs the DBOSReviver function during parsing
         * - SuperJSON data must be parsed WITHOUT the reviver (it would corrupt the structure)
         * - We can't know which parser to use without inspecting the data first
         *
         * This string check lets us:
         * 1. Parse legacy data correctly with DBOSReviver in one pass (99% of cases)
         * 2. Only double-parse when we detect new SuperJSON format (rare for now)
         * 3. Avoid corrupting SuperJSON's meta structure with the wrong reviver
         */
        const hasSuperJSONMarker = text.includes(SERIALIZER_MARKER_STRING);
        if (hasSuperJSONMarker) {
            // Parse without reviver first to check if it's really our SuperJSON format
            const vanillaParsed = JSON.parse(text);
            if (isDBOSBrandedSuperjsonRecord(vanillaParsed)) {
                return superjson_1.default.deserialize(vanillaParsed);
            }
            // False positive - user data happened to contain our marker string
            // Fall through to parse with reviver
        }
        // Legacy DBOSJSON format
        return exports.DBOSJSONLegacy.parse(text);
    },
    stringify: sjstringify,
};
/**
 * Roundtrips `value` through serialization.  This doesn't preserve functions by default.
 *   So then, we recursively attach function stubs that throw clear errors, for any
 *   functions present on the original (own props + prototype methods) that
 *   aren't present as functions on the deserialized object.
 * The return is both the deserialized object and its serialized string.
 */
function serializeFunctionInputOutput(value, path = [], serializer) {
    const stringified = serializer.stringify(value);
    const deserialized = serializer.parse(stringified);
    if (serializer === exports.DBOSJSON && isObjectish(deserialized)) {
        attachFunctionStubs(value, deserialized, path);
    }
    return { deserialized, stringified };
}
exports.serializeFunctionInputOutput = serializeFunctionInputOutput;
// Walks original & deserialized in lockstep and attaches stubs for missing functions.
function attachFunctionStubs(original, deserialized, path = []) {
    // Avoid infinite cycles
    const seen = new WeakSet();
    const pairQueue = [{ o: original, d: deserialized, p: path }];
    while (pairQueue.length) {
        const { o, d, p } = pairQueue.pop();
        if (seen.has(o))
            continue;
        seen.add(o);
        // Collect function keys from the original
        for (const key of collectFunctionKeys(o)) {
            if (!(key in d)) {
                defineThrowingStub(d, key, p);
            }
        }
        // Recurse into child properties (plain objects & arrays, but not maps/sets)
        for (const key of getAllKeys(o)) {
            try {
                const childO = o[key];
                const childD = d[key];
                if (!shouldRecurse(childO, childD))
                    continue;
                pairQueue.push({ o: childO, d: childD, p: [...p, key] });
            }
            catch {
                // Ignore property accessors that throw
            }
        }
        // Map/Set values
        if (o instanceof Map && d instanceof Map) {
            for (const [k, vO] of o) {
                const vD = d.get(k);
                if (shouldRecurse(vO, vD)) {
                    const step = isIndexableKey(k) ? String(k) : '[MapValue]';
                    pairQueue.push({ o: vO, d: vD, p: [...p, step] });
                }
            }
        }
        if (o instanceof Set && d instanceof Set) {
            const arrO = Array.from(o);
            const arrD = Array.from(d);
            for (let i = 0; i < Math.min(arrO.length, arrD.length); i++) {
                const vO = arrO[i];
                const vD = arrD[i];
                if (shouldRecurse(vO, vD)) {
                    pairQueue.push({ o: vO, d: vD, p: [...p, i] });
                }
            }
        }
    }
}
function isObjectish(v) {
    return (typeof v === 'object' && v !== null) || typeof v === 'function';
}
function defineThrowingStub(target, key, path) {
    const stub = function (..._args) {
        throw new Error(`Attempted to call '${String(key)}' at path ${formatPath(path)} on an object that is a serialized function input our output value. ` +
            `Functions are not preserved through serialization; see 'DBOS.registerSerialization'. `);
    };
    try {
        Object.defineProperty(target, key, {
            value: stub,
            configurable: true,
            writable: false,
            enumerable: false,
        });
    }
    catch {
        // Fall back to assignment
        target[key] = stub;
    }
}
function shouldRecurse(a, b) {
    if (!a || !b)
        return false;
    if (typeof a !== 'object' || typeof b !== 'object')
        return false;
    // Avoid recursing into special non-plain objects (Date, RegExp, etc.)
    const bad = [Date, RegExp, WeakMap, WeakSet, ArrayBuffer, DataView];
    if (bad.some((t) => a instanceof t))
        return false;
    return true;
}
function getAllKeys(obj) {
    const names = Object.getOwnPropertyNames(obj);
    const syms = Object.getOwnPropertySymbols(obj);
    return [...names, ...syms];
}
function collectFunctionKeys(obj) {
    const keys = new Set();
    // Own props
    for (const k of getAllKeys(obj)) {
        const d = Object.getOwnPropertyDescriptor(obj, k);
        if (d && 'value' in d && typeof d.value === 'function')
            keys.add(k);
    }
    // Prototype chain methods (so we also stub class methods lost after deserialization)
    let proto = Object.getPrototypeOf(obj);
    while (proto && proto !== Object.prototype) {
        for (const k of Object.getOwnPropertyNames(proto)) {
            if (k === 'constructor')
                continue;
            const d = Object.getOwnPropertyDescriptor(proto, k);
            if (d && 'value' in d && typeof d.value === 'function')
                keys.add(k);
        }
        proto = Object.getPrototypeOf(proto);
    }
    return Array.from(keys);
}
function formatPath(path) {
    if (path.length === 0)
        return '(root)';
    return path
        .map((seg) => typeof seg === 'number'
        ? `[${seg}]`
        : typeof seg === 'symbol'
            ? `[${String(seg)}]`
            : /^<?[A-Za-z_$][A-Za-z0-9_$]*>?$/.test(seg)
                ? `.${seg}`
                : `[${JSON.stringify(seg)}]`)
        .join('')
        .replace(/^\./, '');
}
function isIndexableKey(k) {
    return typeof k === 'string' || typeof k === 'number';
}
// Attempt to deserialize a value, but if it fails, retun the raw string.
// Used for "best-effort" in introspection methods which may encounter
// old undeserializable data.
function safeParse(serializer, val) {
    try {
        return serializer.parse(val);
    }
    catch (e) {
        return val;
    }
}
exports.safeParse = safeParse;
function safeParseError(serializer, val) {
    try {
        return (0, serialize_error_1.deserializeError)(serializer.parse(val));
    }
    catch (e) {
        return val;
    }
}
exports.safeParseError = safeParseError;
//# sourceMappingURL=serialization.js.map
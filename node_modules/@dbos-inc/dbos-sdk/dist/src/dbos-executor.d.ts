import { type WorkflowHandle, type WorkflowParams, type WorkflowStatus, type StepInfo } from './workflow';
import { type StepConfig } from './step';
import { TelemetryCollector } from './telemetry/collector';
import { Tracer } from './telemetry/traces';
import { DBOSContextualLogger, GlobalLogger } from './telemetry/logs';
import { type SystemDatabase, type SystemDatabaseStoredResult } from './system_database';
import { UntypedAsyncFunction, TypedAsyncFunction } from './decorators';
import type { step_info } from '../schemas/system_db_schema';
import { DBOSSerializer } from './serialization';
import { GetWorkflowsInput } from '.';
import { WorkflowQueue } from './wfqueue';
import { Pool } from 'pg';
export declare const DBOS_QUEUE_MIN_PRIORITY = 1;
export declare const DBOS_QUEUE_MAX_PRIORITY: number;
export interface DBOSConfig {
    name?: string;
    systemDatabaseUrl?: string;
    systemDatabasePoolSize?: number;
    systemDatabasePool?: Pool;
    systemDatabaseSchemaName?: string;
    enableOTLP?: boolean;
    logLevel?: string;
    addContextMetadata?: boolean;
    otlpTracesEndpoints?: string[];
    otlpLogsEndpoints?: string[];
    adminPort?: number;
    runAdminServer?: boolean;
    applicationVersion?: string;
    executorID?: string;
    serializer?: DBOSSerializer;
    enablePatching?: boolean;
    listenQueues?: WorkflowQueue[];
}
export interface DBOSRuntimeConfig {
    admin_port: number;
    runAdminServer: boolean;
    start: string[];
    setup: string[];
}
export interface TelemetryConfig {
    logs?: LoggerConfig;
    OTLPExporter?: OTLPExporterConfig;
}
export interface OTLPExporterConfig {
    logsEndpoint?: string[];
    tracesEndpoint?: string[];
}
export interface LoggerConfig {
    logLevel?: string;
    silent?: boolean;
    addContextMetadata?: boolean;
    forceConsole?: boolean;
}
export type DBOSConfigInternal = {
    name?: string;
    systemDatabaseUrl: string;
    sysDbPoolSize?: number;
    systemDatabasePool?: Pool;
    systemDatabaseSchemaName: string;
    serializer: DBOSSerializer;
    telemetry: TelemetryConfig;
    http?: {
        cors_middleware?: boolean;
        credentials?: boolean;
        allowed_origins?: string[];
    };
};
export interface InternalWorkflowParams extends WorkflowParams {
    readonly tempWfType?: string;
    readonly tempWfName?: string;
    readonly tempWfClass?: string;
    readonly isRecoveryDispatch?: boolean;
    readonly isQueueDispatch?: boolean;
}
export declare const OperationType: {
    readonly HANDLER: "handler";
    readonly WORKFLOW: "workflow";
    readonly TRANSACTION: "transaction";
    readonly STEP: "step";
};
export declare const TempWorkflowType: {
    readonly step: "step";
    readonly send: "send";
};
/**
 * State item to be kept in the DBOS system database on behalf of clients
 */
export interface DBOSExternalState {
    /** Name of event receiver service */
    service: string;
    /** Fully qualified function name for which state is kept */
    workflowFnName: string;
    /** subkey within the service+workflowFnName */
    key: string;
    /** Value kept for the service+workflowFnName+key combination */
    value?: string;
    /** Updated time (used to version the value) */
    updateTime?: number;
    /** Updated sequence number (used to version the value) */
    updateSeq?: bigint;
}
export interface DBOSExecutorOptions {
    systemDatabase?: SystemDatabase;
}
export declare class DBOSExecutor {
    #private;
    readonly config: DBOSConfigInternal;
    initialized: boolean;
    readonly systemDatabase: SystemDatabase;
    readonly telemetryCollector: TelemetryCollector;
    static readonly defaultNotificationTimeoutSec = 60;
    readonly systemDBSchemaName: string;
    readonly logger: GlobalLogger;
    readonly ctxLogger: DBOSContextualLogger;
    readonly tracer: Tracer;
    readonly serializer: DBOSSerializer;
    readonly executorID: string;
    static globalInstance: DBOSExecutor | undefined;
    constructor(config: DBOSConfigInternal, { systemDatabase }?: DBOSExecutorOptions);
    get appName(): string | undefined;
    init(): Promise<void>;
    destroy(): Promise<void>;
    static reviveResultOrError<R = unknown>(r: SystemDatabaseStoredResult, serializer: DBOSSerializer): R;
    workflow<T extends unknown[], R>(wf: TypedAsyncFunction<T, R>, params: InternalWorkflowParams, ...args: T): Promise<WorkflowHandle<R>>;
    internalWorkflow<T extends unknown[], R>(wf: TypedAsyncFunction<T, R>, params: InternalWorkflowParams, callerID?: string, callerFunctionID?: number, ...args: T): Promise<WorkflowHandle<R>>;
    getQueueByName(name: string): WorkflowQueue;
    runStepTempWF<T extends unknown[], R>(stepFn: TypedAsyncFunction<T, R>, params: WorkflowParams, ...args: T): Promise<R>;
    startStepTempWF<T extends unknown[], R>(stepFn: TypedAsyncFunction<T, R>, params: InternalWorkflowParams, callerWFID?: string, callerFunctionID?: number, ...args: T): Promise<WorkflowHandle<R>>;
    /**
     * Execute a step function.
     * If it encounters any error, retry according to its configured retry policy until the maximum number of attempts is reached, then throw an DBOSError.
     * The step may execute many times, but once it is complete, it will not re-execute.
     */
    callStepFunction<T extends unknown[], R>(stepFn: TypedAsyncFunction<T, R>, stepFnName: string | undefined, stepConfig: StepConfig | undefined, clsInst: object | null, ...args: T): Promise<R>;
    runSendTempWF<T>(destinationId: string, message: T, topic?: string, idempotencyKey?: string): Promise<void>;
    /**
     * Wait for a workflow to emit an event, then return its value.
     */
    getEvent<T>(workflowUUID: string, key: string, timeoutSeconds?: number): Promise<T | null>;
    /**
     * Fork a workflow.
     * The forked workflow will be assigned a new ID.
     */
    forkWorkflow(workflowID: string, startStep: number, options?: {
        newWorkflowID?: string;
        applicationVersion?: string;
        timeoutMS?: number;
    }): Promise<string>;
    /**
     * Retrieve a handle for a workflow UUID.
     */
    retrieveWorkflow<R>(workflowID: string): WorkflowHandle<R>;
    runInternalStep<T>(callback: () => Promise<T>, functionName: string, workflowID: string, functionID: number, childWfId?: string): Promise<T>;
    getWorkflowStatus(workflowID: string, callerID?: string, callerFN?: number): Promise<WorkflowStatus | null>;
    listWorkflows(input: GetWorkflowsInput): Promise<WorkflowStatus[]>;
    listQueuedWorkflows(input: GetWorkflowsInput): Promise<WorkflowStatus[]>;
    listWorkflowSteps(workflowID: string): Promise<StepInfo[] | undefined>;
    /**
     * A recovery process that by default runs during executor init time.
     * It runs to completion all pending workflows that were executing when the previous executor failed.
     */
    recoverPendingWorkflows(executorIDs?: string[]): Promise<WorkflowHandle<unknown>[]>;
    initEventReceivers(listenQueues: WorkflowQueue[] | null): Promise<void>;
    deactivateEventReceivers(stopQueueThread?: boolean): Promise<void>;
    executeWorkflowId(workflowID: string, options?: {
        startNewWorkflow?: boolean;
        isRecoveryDispatch?: boolean;
        isQueueDispatch?: boolean;
    }): Promise<WorkflowHandle<unknown>>;
    getEventDispatchState(svc: string, wfn: string, key: string): Promise<DBOSExternalState | undefined>;
    upsertEventDispatchState(state: DBOSExternalState): Promise<DBOSExternalState>;
    cancelWorkflow(workflowID: string): Promise<void>;
    getWorkflowSteps(workflowID: string): Promise<step_info[]>;
    resumeWorkflow(workflowID: string): Promise<void>;
    deleteWorkflow(workflowID: string, deleteChildren?: boolean): Promise<void>;
    /**
      An application's version is computed from a hash of the source of its workflows.
      This is guaranteed to be stable given identical source code because it uses an MD5 hash
      and because it iterates through the workflows in sorted order.
      This way, if the app's workflows are updated (which would break recovery), its version changes.
      App version can be manually set through the DBOS__APPVERSION environment variable.
     */
    computeAppVersion(): string;
    static internalQueue: WorkflowQueue | undefined;
    static createInternalQueue(): void;
    static debouncerWorkflow: UntypedAsyncFunction | undefined;
    static createDebouncerWorkflow(): void;
}
//# sourceMappingURL=dbos-executor.d.ts.map
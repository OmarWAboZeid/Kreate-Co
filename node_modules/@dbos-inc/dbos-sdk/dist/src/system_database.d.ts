/// <reference types="node" />
import { DBOSExternalState } from './dbos-executor';
import { Pool, PoolClient } from 'pg';
import { GetPendingWorkflowsOutput, GetWorkflowsInput, StatusString } from './workflow';
import { operation_outputs, workflow_status, workflow_events, workflow_events_history, streams } from '../schemas/system_db_schema';
import { GlobalLogger } from './telemetry/logs';
import { WorkflowQueue } from './wfqueue';
import { DBOSSerializer } from './serialization';
export interface SystemDatabaseStoredResult {
    output?: string | null;
    error?: string | null;
    cancelled?: boolean;
    childWorkflowID?: string | null;
    functionName?: string;
}
export interface ExportedWorkflow {
    workflow_status: workflow_status;
    operation_outputs: operation_outputs[];
    workflow_events: workflow_events[];
    workflow_events_history: workflow_events_history[];
    streams: streams[];
}
export declare const DBOS_FUNCNAME_SEND = "DBOS.send";
export declare const DBOS_FUNCNAME_RECV = "DBOS.recv";
export declare const DBOS_FUNCNAME_SETEVENT = "DBOS.setEvent";
export declare const DBOS_FUNCNAME_GETEVENT = "DBOS.getEvent";
export declare const DBOS_FUNCNAME_SLEEP = "DBOS.sleep";
export declare const DBOS_FUNCNAME_GETSTATUS = "getStatus";
export declare const DBOS_FUNCNAME_WRITESTREAM = "DBOS.writeStream";
export declare const DBOS_FUNCNAME_CLOSESTREAM = "DBOS.closeStream";
export declare const DEFAULT_POOL_SIZE = 10;
export declare const DBOS_STREAM_CLOSED_SENTINEL = "__DBOS_STREAM_CLOSED__";
/**
 * General notes:
 *   The responsibilities of the `SystemDatabase` are to store data for workflows, and
 *     associated steps, transactions, messages, and events.  The system DB is
 *     also the IPC mechanism that performs notifications when things change, for
 *     example a receive is unblocked when a send occurs, or a cancel interrupts
 *     the receive.
 *   The `SystemDatabase` expects values in inputs/outputs/errors to be JSON.  However,
 *     the serialization process of turning data into JSON or converting it back, should
 *     be done elsewhere (executor), as it may require application-specific logic or extensions.
 */
export interface SystemDatabase {
    init(): Promise<void>;
    destroy(): Promise<void>;
    initWorkflowStatus(initStatus: WorkflowStatusInternal, ownerXid: string | null, options?: {
        isRecoveryRequest?: boolean;
        isDequeuedRequest?: boolean;
        maxRetries?: number;
    }): Promise<{
        status: string;
        shouldExecuteOnThisExecutor: boolean;
        deadlineEpochMS?: number;
    }>;
    recordWorkflowOutput(workflowID: string, status: WorkflowStatusInternal): Promise<void>;
    recordWorkflowError(workflowID: string, status: WorkflowStatusInternal): Promise<void>;
    getPendingWorkflows(executorID: string, appVersion: string): Promise<GetPendingWorkflowsOutput[]>;
    getOperationResultAndThrowIfCancelled(workflowID: string, functionID: number): Promise<SystemDatabaseStoredResult | undefined>;
    getAllOperationResults(workflowID: string): Promise<operation_outputs[]>;
    recordOperationResult(workflowID: string, functionID: number, functionName: string, checkConflict: boolean, startTimeEpochMs: number, options?: {
        childWorkflowID?: string | null;
        output?: string | null;
        error?: string | null;
    }): Promise<void>;
    getWorkflowStatus(workflowID: string, callerID?: string, callerFN?: number): Promise<WorkflowStatusInternal | null>;
    awaitWorkflowResult(workflowID: string, timeoutSeconds?: number, callerID?: string, timerFuncID?: number): Promise<SystemDatabaseStoredResult | undefined>;
    setWorkflowStatus(workflowID: string, status: (typeof StatusString)[keyof typeof StatusString], resetRecoveryAttempts: boolean): Promise<void>;
    cancelWorkflow(workflowID: string): Promise<void>;
    resumeWorkflow(workflowID: string): Promise<void>;
    deleteWorkflow(workflowID: string, deleteChildren?: boolean): Promise<void>;
    getWorkflowChildren(workflowID: string): Promise<string[]>;
    exportWorkflow(workflowID: string, exportChildren?: boolean): Promise<ExportedWorkflow[]>;
    importWorkflow(workflows: ExportedWorkflow[]): Promise<void>;
    forkWorkflow(workflowID: string, startStep: number, options?: {
        newWorkflowID?: string;
        applicationVersion?: string;
        timeoutMS?: number;
    }): Promise<string>;
    checkIfCanceled(workflowID: string): Promise<void>;
    registerRunningWorkflow(workflowID: string, workflowPromise: Promise<unknown>): void;
    checkForRunningWorkflow(workflowID: string): boolean;
    awaitRunningWorkflows(): Promise<void>;
    clearQueueAssignment(workflowID: string): Promise<boolean>;
    getDeduplicatedWorkflow(queueName: string, deduplicationID: string): Promise<string | null>;
    getQueuePartitions(queueName: string): Promise<string[]>;
    findAndMarkStartableWorkflows(queue: WorkflowQueue, executorID: string, appVersion: string, queuePartitionKey?: string | null): Promise<string[]>;
    durableSleepms(workflowID: string, functionID: number, duration: number): Promise<void>;
    send(workflowID: string, functionID: number, destinationID: string, message: string | null, topic?: string): Promise<void>;
    recv(workflowID: string, functionID: number, timeoutFunctionID: number, topic?: string, timeoutSeconds?: number): Promise<string | null>;
    setEvent(workflowID: string, functionID: number, key: string, value: string | null): Promise<void>;
    getEvent(workflowID: string, key: string, timeoutSeconds: number, callerWorkflow?: {
        workflowID: string;
        functionID: number;
        timeoutFunctionID: number;
    }): Promise<string | null>;
    getEventDispatchState(service: string, workflowFnName: string, key: string): Promise<DBOSExternalState | undefined>;
    upsertEventDispatchState(state: DBOSExternalState): Promise<DBOSExternalState>;
    writeStreamFromWorkflow(workflowID: string, functionID: number, key: string, value: unknown): Promise<void>;
    writeStreamFromStep(workflowID: string, functionID: number, key: string, value: unknown): Promise<void>;
    closeStream(workflowID: string, functionID: number, key: string): Promise<void>;
    readStream(workflowID: string, key: string, offset: number): Promise<unknown>;
    listWorkflows(input: GetWorkflowsInput): Promise<WorkflowStatusInternal[]>;
    garbageCollect(cutoffEpochTimestampMs?: number, rowsThreshold?: number): Promise<void>;
    getMetrics(startTime: string, endTime: string): Promise<MetricData[]>;
    checkPatch(workflowID: string, functionID: number, patchName: string, deprecated: boolean): Promise<{
        isPatched: boolean;
        hasEntry: boolean;
    }>;
    getSerializer(): DBOSSerializer;
}
export interface WorkflowStatusInternal {
    workflowUUID: string;
    status: string;
    workflowName: string;
    workflowClassName: string;
    workflowConfigName: string;
    queueName?: string;
    authenticatedUser: string;
    output: string | null;
    error: string | null;
    input: string | null;
    assumedRole: string;
    authenticatedRoles: string[];
    request: object;
    executorId: string;
    applicationVersion?: string;
    applicationID: string;
    createdAt: number;
    updatedAt?: number;
    recoveryAttempts?: number;
    timeoutMS?: number;
    deadlineEpochMS?: number;
    deduplicationID?: string;
    priority: number;
    queuePartitionKey?: string;
    forkedFrom?: string;
}
export interface EnqueueOptions {
    deduplicationID?: string;
    priority?: number;
    queuePartitionKey?: string;
}
export interface ExistenceCheck {
    exists: boolean;
}
export interface MetricData {
    metricType: string;
    metricName: string;
    value: number;
}
export declare function grantDbosSchemaPermissions(databaseUrl: string, roleName: string, logger: GlobalLogger, schemaName?: string): Promise<void>;
export declare function ensureSystemDatabase(sysDbUrl: string, logger: GlobalLogger, customPool?: Pool, schemaName?: string): Promise<void>;
declare class NotificationMap<T> {
    map: Map<string, Map<number, (event?: T) => void>>;
    curCK: number;
    registerCallback(key: string, cb: (event?: T) => void): {
        key: string;
        ck: number;
    };
    deregisterCallback(k: {
        key: string;
        ck: number;
    }): void;
    callCallbacks(key: string, event?: T): void;
}
export declare class PostgresSystemDatabase implements SystemDatabase {
    #private;
    readonly systemDatabaseUrl: string;
    readonly logger: GlobalLogger;
    readonly serializer: DBOSSerializer;
    readonly pool: Pool;
    readonly schemaName: string;
    notificationsClient: PoolClient | null;
    dbPollingIntervalResultMs: number;
    dbPollingIntervalEventMs: number;
    shouldUseDBNotifications: boolean;
    readonly notificationsMap: NotificationMap<void>;
    readonly workflowEventsMap: NotificationMap<void>;
    readonly cancelWakeupMap: NotificationMap<void>;
    customPool: boolean;
    readonly runningWorkflowMap: Map<string, Promise<unknown>>;
    readonly workflowCancellationMap: Map<string, boolean>;
    constructor(systemDatabaseUrl: string, logger: GlobalLogger, serializer: DBOSSerializer, sysDbPoolSize?: number, systemDatabasePool?: Pool, schemaName?: string);
    getSerializer(): DBOSSerializer;
    init(): Promise<void>;
    destroy(): Promise<void>;
    initWorkflowStatus(initStatus: WorkflowStatusInternal, ownerXid: string | null, options?: {
        isRecoveryRequest?: boolean;
        isDequeuedRequest?: boolean;
        maxRetries?: number;
    }): Promise<{
        status: string;
        shouldExecuteOnThisExecutor: boolean;
        deadlineEpochMS?: number;
    }>;
    recordWorkflowOutput(workflowID: string, status: WorkflowStatusInternal): Promise<void>;
    recordWorkflowError(workflowID: string, status: WorkflowStatusInternal): Promise<void>;
    getPendingWorkflows(executorID: string, appVersion: string): Promise<GetPendingWorkflowsOutput[]>;
    getOperationResultAndThrowIfCancelled(workflowID: string, functionID: number): Promise<SystemDatabaseStoredResult | undefined>;
    getAllOperationResults(workflowID: string): Promise<operation_outputs[]>;
    recordOperationResult(workflowID: string, functionID: number, functionName: string, checkConflict: boolean, startTimeEpochMs: number, options?: {
        childWorkflowID?: string | null;
        output?: string | null;
        error?: string | null;
    }): Promise<void>;
    forkWorkflow(workflowID: string, startStep: number, options?: {
        newWorkflowID?: string;
        applicationVersion?: string;
        timeoutMS?: number;
    }): Promise<string>;
    durableSleepms(workflowID: string, functionID: number, durationMS: number): Promise<void>;
    readonly nullTopic = "__null__topic__";
    send(workflowID: string, functionID: number, destinationID: string, message: string | null, topic?: string): Promise<void>;
    recv(workflowID: string, functionID: number, timeoutFunctionID: number, topic?: string, timeoutSeconds?: number): Promise<string | null>;
    setWorkflowStatus(workflowID: string, status: (typeof StatusString)[keyof typeof StatusString], resetRecoveryAttempts: boolean, internalOptions?: {
        updateName?: string;
    }): Promise<void>;
    setEvent(workflowID: string, functionID: number, key: string, message: string | null): Promise<void>;
    getEvent(workflowID: string, key: string, timeoutSeconds: number, callerWorkflow?: {
        workflowID: string;
        functionID: number;
        timeoutFunctionID: number;
    }): Promise<string | null>;
    cancelWorkflow(workflowID: string): Promise<void>;
    checkIfCanceled(workflowID: string): Promise<void>;
    resumeWorkflow(workflowID: string): Promise<void>;
    getWorkflowChildren(workflowID: string): Promise<string[]>;
    deleteWorkflow(workflowID: string, deleteChildren?: boolean): Promise<void>;
    exportWorkflow(workflowID: string, exportChildren?: boolean): Promise<ExportedWorkflow[]>;
    importWorkflow(workflows: ExportedWorkflow[]): Promise<void>;
    registerRunningWorkflow(workflowID: string, workflowPromise: Promise<unknown>): void;
    checkForRunningWorkflow(workflowID: string): boolean;
    awaitRunningWorkflows(): Promise<void>;
    getWorkflowStatus(workflowID: string, callerID?: string, callerFN?: number): Promise<WorkflowStatusInternal | null>;
    awaitWorkflowResult(workflowID: string, timeoutSeconds?: number, callerID?: string, timerFuncID?: number): Promise<SystemDatabaseStoredResult | undefined>;
    /**
     * A background process that listens for notifications from Postgres then signals the appropriate
     * workflow listener by resolving its promise.
     */
    reconnectTimeout: NodeJS.Timeout | null;
    getEventDispatchState(service: string, workflowName: string, key: string): Promise<DBOSExternalState | undefined>;
    upsertEventDispatchState(state: DBOSExternalState): Promise<DBOSExternalState>;
    listWorkflows(input: GetWorkflowsInput): Promise<WorkflowStatusInternal[]>;
    clearQueueAssignment(workflowID: string): Promise<boolean>;
    getDeduplicatedWorkflow(queueName: string, deduplicationID: string): Promise<string | null>;
    getQueuePartitions(queueName: string): Promise<string[]>;
    findAndMarkStartableWorkflows(queue: WorkflowQueue, executorID: string, appVersion: string, queuePartitionKey?: string): Promise<string[]>;
    writeStreamFromStep(workflowID: string, functionID: number, key: string, value: unknown): Promise<void>;
    writeStreamFromWorkflow(workflowID: string, functionID: number, key: string, value: unknown): Promise<void>;
    closeStream(workflowID: string, functionID: number, key: string): Promise<void>;
    readStream(workflowID: string, key: string, offset: number): Promise<unknown>;
    garbageCollect(cutoffEpochTimestampMs?: number, rowsThreshold?: number): Promise<void>;
    getMetrics(startTime: string, endTime: string): Promise<MetricData[]>;
    checkPatch(workflowID: string, functionID: number, patchName: string, deprecated: boolean): Promise<{
        isPatched: boolean;
        hasEntry: boolean;
    }>;
}
export {};
//# sourceMappingURL=system_database.d.ts.map
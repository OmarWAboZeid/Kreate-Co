import type { JSONValue } from 'superjson/dist/types';
export { type JSONValue };
/**
 * Generic serializer interface for DBOS.
 * Implementations must be able to serialize any value to a string and deserialize it back.
 */
export interface DBOSSerializer {
    /**
     * Serialize a value to a string.
     * @param value - The value to serialize
     * @returns The serialized string representation
     */
    stringify(value: unknown): string;
    /**
     * Deserialize a string back to a value.
     * @param text - A serialized string (potentially null or undefined)
     * @returns The deserialized value, or null if the input was null/undefined
     */
    parse(text: string | null | undefined): unknown;
}
export type SerializationRecipe<T, S extends JSONValue> = {
    name: string;
    isApplicable: (v: unknown) => v is T;
    serialize: (v: T) => S;
    deserialize: (s: S) => T;
};
export declare function registerSerializationRecipe<T, S extends JSONValue>(r: SerializationRecipe<T, S>): void;
export declare function DBOSReplacer(this: any, key: string, value: unknown): unknown;
export declare function DBOSReviver(_key: string, value: unknown): unknown;
export declare const DBOSJSONLegacy: {
    parse: (text: string | null) => any;
    stringify: (value: unknown) => string | undefined;
};
export declare const SERIALIZER_MARKER_KEY = "__dbos_serializer";
export declare const SERIALIZER_MARKER_VALUE = "superjson";
/**
 * DBOSJSON with SuperJSON support for richer type serialization.
 *
 * Backwards compatible - can deserialize both old DBOSJSON format and new SuperJSON format.
 * New serialization uses SuperJSON to handle Sets, Maps, undefined, RegExp, circular refs, etc.
 */
export declare const DBOSJSON: DBOSSerializer;
type PathToMember = Array<string | number | symbol>;
/**
 * Roundtrips `value` through serialization.  This doesn't preserve functions by default.
 *   So then, we recursively attach function stubs that throw clear errors, for any
 *   functions present on the original (own props + prototype methods) that
 *   aren't present as functions on the deserialized object.
 * The return is both the deserialized object and its serialized string.
 */
export declare function serializeFunctionInputOutput<T>(value: T, path: PathToMember | undefined, serializer: DBOSSerializer): {
    deserialized: T;
    stringified: string;
};
export declare function safeParse(serializer: DBOSSerializer, val: string): unknown;
export declare function safeParseError(serializer: DBOSSerializer, val: string): Error;
//# sourceMappingURL=serialization.d.ts.map
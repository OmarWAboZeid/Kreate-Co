"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.wfQueueRunner = exports.WorkflowQueue = void 0;
const dbos_1 = require("./dbos");
const debugpoint_1 = require("./debugpoint");
const utils_1 = require("./utils");
/**
 * Settings structure for a named workflow queue.
 * Workflow queues limit the rate and concurrency at which DBOS executes workflows.
 * Queue policies apply to workflows started by `DBOS.startWorkflow`,
 *   `DBOS.withWorkflowQueue`, etc.
 */
class WorkflowQueue {
    name;
    concurrency;
    rateLimit;
    workerConcurrency;
    priorityEnabled = false;
    partitionQueue = false;
    constructor(name, arg2, rateLimit) {
        this.name = name;
        if (dbos_1.DBOS.isInitialized()) {
            dbos_1.DBOS.logger.warn(`Workflow queue '${name}' is being created after DBOS initialization and will not be considered for dequeue.`);
        }
        if (typeof arg2 === 'object' && arg2 !== null) {
            // Handle the case where the second argument is QueueParameters
            this.concurrency = arg2.concurrency;
            this.rateLimit = arg2.rateLimit;
            this.workerConcurrency = arg2.workerConcurrency;
            this.priorityEnabled = arg2.priorityEnabled ?? false;
            this.partitionQueue = arg2.partitionQueue ?? false;
        }
        else {
            // Handle the case where the second argument is a number
            this.concurrency = arg2;
            this.rateLimit = rateLimit;
        }
        if (exports.wfQueueRunner.wfQueuesByName.has(name)) {
            throw Error(`Workflow Queue '${name}' defined multiple times`);
        }
        exports.wfQueueRunner.wfQueuesByName.set(name, this);
    }
}
exports.WorkflowQueue = WorkflowQueue;
class WFQueueRunner {
    wfQueuesByName = new Map();
    isRunning = false;
    interruptResolve;
    pollingIntervalMs = 1000;
    minPollingIntervalMs = 1000;
    maxPollingIntervalMs = 120000;
    stop() {
        if (!this.isRunning)
            return;
        this.isRunning = false;
        if (this.interruptResolve) {
            this.interruptResolve();
        }
    }
    clearRegistrations() {
        this.wfQueuesByName.clear();
    }
    async dispatchLoop(exec, listenQueuesArg) {
        this.isRunning = true;
        while (this.isRunning) {
            // Wait for either the timeout or an interruption
            let timer;
            const timeoutPromise = new Promise((resolve) => {
                timer = setTimeout(() => {
                    resolve();
                }, this.pollingIntervalMs);
            });
            await Promise.race([timeoutPromise, new Promise((_, reject) => (this.interruptResolve = reject))]).catch(() => {
                exec.logger.debug('Workflow queue loop interrupted!');
            }); // Interrupt sleep throws
            clearTimeout(timer);
            if (!this.isRunning) {
                break;
            }
            let listenQueues;
            if (listenQueuesArg !== null) {
                // If explicitly listening for queues, use only those queues plus the internal queue
                listenQueues = [...listenQueuesArg, this.wfQueuesByName.get(utils_1.INTERNAL_QUEUE_NAME)];
            }
            else {
                // Else, listen to all declared queues
                listenQueues = Array.from(this.wfQueuesByName.values());
            }
            // Check queues
            for (const q of listenQueues) {
                let wfids = [];
                try {
                    if (q.partitionQueue) {
                        // For partitioned queues, get all partition keys and dequeue from each partition separately
                        const partitionKeys = await exec.systemDatabase.getQueuePartitions(q.name);
                        for (const partitionKey of partitionKeys) {
                            const partitionWfids = await exec.systemDatabase.findAndMarkStartableWorkflows(q, exec.executorID, utils_1.globalParams.appVersion, partitionKey);
                            wfids.push(...partitionWfids);
                        }
                    }
                    else {
                        // For non-partitioned queues, pass null to match workflows with queue_partition_key IS NULL
                        wfids = await exec.systemDatabase.findAndMarkStartableWorkflows(q, exec.executorID, utils_1.globalParams.appVersion, undefined);
                    }
                }
                catch (e) {
                    const err = e;
                    // Handle serialization errors and lock contention with backoff
                    if ('code' in err && (err.code === '40001' || err.code === '55P03')) {
                        // 40001: serialization_failure, 55P03: lock_not_available
                        // Increase the polling interval on contention
                        this.pollingIntervalMs = Math.min(this.maxPollingIntervalMs, this.pollingIntervalMs * 2.0);
                        exec.logger.warn(`Contention detected in queue thread for ${q.name}. Increasing polling interval to ${(this.pollingIntervalMs / 1000).toFixed(2)}s.`);
                    }
                    else {
                        exec.logger.warn(`Error getting startable workflows: ${err.message}`);
                    }
                    wfids = [];
                }
                if (wfids.length > 0) {
                    await (0, debugpoint_1.debugTriggerPoint)(debugpoint_1.DEBUG_TRIGGER_WORKFLOW_QUEUE_START);
                }
                for (const wfid of wfids) {
                    try {
                        const _wfh = await exec.executeWorkflowId(wfid, { isQueueDispatch: true });
                    }
                    catch (e) {
                        exec.logger.warn(`Could not execute workflow with id ${wfid}: ${e.message}`);
                    }
                }
            }
            // Gradually decrease the polling interval when there's no contention
            this.pollingIntervalMs = Math.max(this.minPollingIntervalMs, this.pollingIntervalMs * 0.9);
        }
    }
    logRegisteredEndpoints(exec) {
        const logger = exec.logger;
        logger.info('Workflow queues:');
        for (const [qn, q] of this.wfQueuesByName) {
            const conc = q.concurrency !== undefined ? `global concurrency limit: ${q.concurrency}` : 'No concurrency limit set';
            logger.info(`    ${qn}: ${conc}`);
            const workerconc = q.workerConcurrency !== undefined
                ? `worker concurrency limit: ${q.workerConcurrency}`
                : 'No worker concurrency limit set';
            logger.info(`    ${qn}: ${workerconc}`);
        }
    }
}
exports.wfQueueRunner = new WFQueueRunner();
//# sourceMappingURL=wfqueue.js.map
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DBOSClient = exports.ClientHandle = void 0;
const system_database_1 = require("./system_database");
const logs_1 = require("./telemetry/logs");
const node_crypto_1 = require("node:crypto");
const workflow_1 = require("./workflow");
const utils_1 = require("./utils");
const serialization_1 = require("./serialization");
const workflow_management_1 = require("./workflow_management");
const dbos_executor_1 = require("./dbos-executor");
const error_1 = require("./error");
class ClientHandle {
    systemDatabase;
    workflowUUID;
    constructor(systemDatabase, workflowUUID) {
        this.systemDatabase = systemDatabase;
        this.workflowUUID = workflowUUID;
    }
    getWorkflowUUID() {
        return this.workflowUUID;
    }
    get workflowID() {
        return this.workflowUUID;
    }
    async getStatus() {
        const status = await this.systemDatabase.getWorkflowStatus(this.workflowUUID);
        return status ? (0, workflow_management_1.toWorkflowStatus)(status, this.systemDatabase.getSerializer()) : null;
    }
    async getResult() {
        const res = await this.systemDatabase.awaitWorkflowResult(this.workflowID);
        if (res?.cancelled) {
            throw new error_1.DBOSAwaitedWorkflowCancelledError(this.workflowID);
        }
        return dbos_executor_1.DBOSExecutor.reviveResultOrError(res, this.systemDatabase.getSerializer());
    }
    async getWorkflowInputs() {
        const status = (await this.systemDatabase.getWorkflowStatus(this.workflowUUID));
        return this.systemDatabase.getSerializer().parse(status.input);
    }
}
exports.ClientHandle = ClientHandle;
/**
 * DBOSClient is the main entry point for interacting with the DBOS system.
 */
class DBOSClient {
    serializer;
    logger;
    systemDatabase;
    constructor(systemDatabaseUrl, systemDatabasePool, serializer) {
        this.serializer = serializer;
        this.logger = new logs_1.GlobalLogger();
        this.systemDatabase = new system_database_1.PostgresSystemDatabase(systemDatabaseUrl, this.logger, serializer, system_database_1.DEFAULT_POOL_SIZE, systemDatabasePool);
    }
    /**
     * Creates a new instance of the DBOSClient.
     * @param databaseUrl - The connection string for the database. This should include the hostname, port, username, password, and database name.
     * @param systemDatabase - An optional name for the system database. If not provided, it defaults to the application database name with a `_dbos_sys` suffix.
     * @returns A Promise that resolves with the DBOSClient instance.
     */
    static async create({ systemDatabaseUrl, systemDatabasePool, serializer, }) {
        const client = new DBOSClient(systemDatabaseUrl, systemDatabasePool, serializer ?? serialization_1.DBOSJSON);
        return Promise.resolve(client);
    }
    /**
     * Destroys the underlying database connection.
     * This should be called when the client is no longer needed to clean up resources.
     * @returns A Promise that resolves when database connection is destroyed.
     */
    async destroy() {
        await this.systemDatabase.destroy();
    }
    /**
     * Enqueues a workflow for execution.
     * @param options - Options for the enqueue operation, including queue name, workflow name, and other parameters.
     * @param args - Arguments to pass to the workflow upon execution.
     * @returns A Promise that resolves when the message has been sent.
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    async enqueue(options, ...args) {
        const { workflowName, workflowClassName, workflowConfigName, queueName, appVersion } = options;
        const workflowUUID = options.workflowID ?? (0, node_crypto_1.randomUUID)();
        const internalStatus = {
            workflowUUID: workflowUUID,
            status: workflow_1.StatusString.ENQUEUED,
            workflowName: workflowName,
            workflowClassName: workflowClassName ?? '',
            workflowConfigName: workflowConfigName ?? '',
            queueName: queueName,
            authenticatedUser: '',
            output: null,
            error: null,
            assumedRole: '',
            authenticatedRoles: [],
            request: {},
            executorId: '',
            applicationVersion: appVersion,
            applicationID: '',
            createdAt: Date.now(),
            timeoutMS: options.workflowTimeoutMS,
            deadlineEpochMS: undefined,
            input: this.serializer.stringify(args),
            deduplicationID: options.deduplicationID,
            priority: options.priority ?? 0,
            queuePartitionKey: options.queuePartitionKey,
        };
        await this.systemDatabase.initWorkflowStatus(internalStatus, null);
        return new ClientHandle(this.systemDatabase, workflowUUID);
    }
    /**
     * Sends a message to a workflow, identified by destinationID.
     * @param destinationID - The ID of the destination workflow.
     * @param message - The message to send. This can be any serializable object.
     * @param topic - An optional topic to send the message to. If not provided, the default topic will be used.
     * @param idempotencyKey - An optional idempotency key to ensure that the message is only sent once.
     * @returns A Promise that resolves when the message has been sent.
     */
    async send(destinationID, message, topic, idempotencyKey) {
        idempotencyKey ??= (0, node_crypto_1.randomUUID)();
        const internalStatus = {
            workflowUUID: `${destinationID}-${idempotencyKey}`,
            status: workflow_1.StatusString.SUCCESS,
            workflowName: 'temp_workflow-send-client',
            workflowClassName: '',
            workflowConfigName: '',
            authenticatedUser: '',
            output: null,
            error: null,
            assumedRole: '',
            authenticatedRoles: [],
            request: {},
            executorId: '',
            applicationID: '',
            createdAt: Date.now(),
            input: this.serializer.stringify([destinationID, message, topic]),
            deduplicationID: undefined,
            priority: 0,
            queuePartitionKey: undefined,
        };
        await this.systemDatabase.initWorkflowStatus(internalStatus, null);
        await this.systemDatabase.send(internalStatus.workflowUUID, 0, destinationID, this.serializer.stringify(message), topic);
    }
    /**
     * Retrieves an event published by workflowID for a given key.
     * @param workflowID - The ID of the workflow that published the event.
     * @param key - The key associated with the event you want to retrieve.
     * @param timeoutSeconds - Timeout in seconds for how long to wait for the event to be available; default 60 seconds.
     * @returns A Promise that resolves with the event payload.
     */
    async getEvent(workflowID, key, timeoutSeconds) {
        return this.serializer.parse(await this.systemDatabase.getEvent(workflowID, key, timeoutSeconds ?? 60));
    }
    /**
     * Retrieves a single workflow by its id.
     * @param workflowID - The ID of the workflow to retrieve.
     * @returns a WorkflowHandle that represents the retrieved workflow.
     */
    retrieveWorkflow(workflowID) {
        return new ClientHandle(this.systemDatabase, workflowID);
    }
    cancelWorkflow(workflowID) {
        return this.systemDatabase.cancelWorkflow(workflowID);
    }
    resumeWorkflow(workflowID) {
        return this.systemDatabase.resumeWorkflow(workflowID);
    }
    forkWorkflow(workflowID, startStep, options) {
        return (0, workflow_management_1.forkWorkflow)(this.systemDatabase, workflowID, startStep, options);
    }
    getWorkflow(workflowID) {
        return (0, workflow_management_1.getWorkflow)(this.systemDatabase, workflowID);
    }
    listWorkflows(input) {
        return (0, workflow_management_1.listWorkflows)(this.systemDatabase, input);
    }
    listQueuedWorkflows(input) {
        return (0, workflow_management_1.listQueuedWorkflows)(this.systemDatabase, input);
    }
    listWorkflowSteps(workflowID) {
        return (0, workflow_management_1.listWorkflowSteps)(this.systemDatabase, workflowID);
    }
    /**
     * Read values from a stream as an async generator.
     * This function reads values from a stream identified by the workflowID and key,
     * yielding each value in order until the stream is closed or the workflow terminates.
     * @param workflowID - The ID of the workflow that wrote to the stream
     * @param key - The stream key to read from
     * @returns An async generator that yields each value in the stream until the stream is closed
     */
    async *readStream(workflowID, key) {
        let offset = 0;
        while (true) {
            try {
                const value = await this.systemDatabase.readStream(workflowID, key, offset);
                if (value === system_database_1.DBOS_STREAM_CLOSED_SENTINEL) {
                    break;
                }
                yield value;
                offset += 1;
            }
            catch (error) {
                if (error instanceof Error && error.message.includes('No value found')) {
                    // Poll the offset until a value arrives or the workflow terminates
                    const status = await this.getWorkflow(workflowID);
                    if (!status || !(0, workflow_1.isWorkflowActive)(status.status)) {
                        break;
                    }
                    await (0, utils_1.sleepms)(1000); // 1 second polling interval
                    continue;
                }
                throw error;
            }
        }
    }
}
exports.DBOSClient = DBOSClient;
//# sourceMappingURL=client.js.map